{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"In\u00edcio","text":""},{"location":"#1-disciplina-de-compiladores","title":"1. Disciplina de Compiladores","text":"<p>Bem\u2011vindo \u00e0 p\u00e1gina inicial da documenta\u00e7\u00e3o do Compiladores \u2013 Grupo 01! Aqui voc\u00ea encontra uma vis\u00e3o geral do projeto, a equipe envolvida e o status de vers\u00f5es. Este \u00e9 um trabalho desenvolvido por alunos do curso de Engenharia de Software da Universidade de Bras\u00edlia, sob orienta\u00e7\u00e3o do Prof. S\u00e9rgio Freitas. O objetivo da disciplina \u00e9 aplicar conceitos de compiladores em um projeto pr\u00e1tico.</p>"},{"location":"#2-projeto","title":"2. Projeto","text":"<p>O compilador implementado traduz um subconjunto de programas escritos em Python para c\u00f3digo em C, utilizando as ferramentas:</p> <ul> <li> <p>Flex: an\u00e1lise l\u00e9xica</p> </li> <li> <p>Bison: an\u00e1lise sint\u00e1tica e montagem de AST</p> </li> <li> <p>Etapa de An\u00e1lise Sem\u00e2ntica: checagem de tipos e escopos b\u00e1sicos</p> </li> <li> <p>Gera\u00e7\u00e3o de C\u00f3digo Intermedi\u00e1rio: estrutura\u00e7\u00e3o de AST para C</p> </li> <li> <p>Gera\u00e7\u00e3o de C\u00f3digo Final: emiss\u00e3o de c\u00f3digo C compil\u00e1vel</p> </li> </ul> <p>Nota: Para instru\u00e7\u00f5es de instala\u00e7\u00e3o e uso, consulte o README ou a se\u00e7\u00e3o \"Como Executar\" na documenta\u00e7\u00e3o.</p>"},{"location":"#3-estrutura","title":"3. Estrutura","text":"<p>A estrutura de pastas e arquivos do reposit\u00f3rio segue o fluxo cl\u00e1ssico de um compilador, organizado em m\u00f3dulos bem definidos:</p> <pre><code>\u251c\u2500\u2500 lexer/             # Regras Flex para an\u00e1lise l\u00e9xica\n\u251c\u2500\u2500 parser/            # Gram\u00e1tica Bison e a\u00e7\u00f5es para AST\n\u251c\u2500\u2500 src/               # C\u00f3digo C principal (main, AST, tabela de s\u00edmbolos)\n\u251c\u2500\u2500 gerarcodigo.c      # Emiss\u00e3o de c\u00f3digo C a partir da AST\n\u251c\u2500\u2500 testes/            # Scripts Python de exemplo e casos de teste\n\u251c\u2500\u2500 docs/              # Documenta\u00e7\u00e3o MkDocs\n\u251c\u2500\u2500 Makefile           # Comandos de build e gera\u00e7\u00e3o\n\u2514\u2500\u2500 README.md          # Tutorial de instala\u00e7\u00e3o e uso\n</code></pre> <p>Essa organiza\u00e7\u00e3o modular torna o projeto mais leg\u00edvel, facilita a manuten\u00e7\u00e3o e deixa claro como cada etapa do compilador est\u00e1 separada em seu pr\u00f3prio componente.</p>"},{"location":"#4-equipe","title":"4. Equipe","text":"<p>A equipe de desenvolvedores \u00e9 composta por 6 membros do curso de Engenharia de Software da Universidade de Bras\u00edlia.</p> Arthur Suares Brunna Louise Genilson Junior Lais Ramos Mariana Let\u00edcia Taynara Marcellos"},{"location":"#5-historico-de-versoes","title":"5. Hist\u00f3rico de Vers\u00f5es","text":"<p>A Tabela 1 registra o hist\u00f3rico de vers\u00e3o desse documento.</p> Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor 27/03/2025 1.0 Primeira Vers\u00e3o do artefato Arthur Suares Genilson Silva 27/03/2025 1.1 Adiciona equipe e hist\u00f3rico de vers\u00f5es Brunna Louise Genilson Silva 27/06/2025 1.2 Ajustes finais para projeto e estrutura Genilson Silva  Tabela 1: Hist\u00f3rico de Vers\u00f5es  Autor(es): Brunna  Fonte: Autor(es)"},{"location":"acompanhamento/semana-01/","title":"Semana 1","text":""},{"location":"acompanhamento/semana-01/#1-resumo-da-semana","title":"1. Resumo da Semana","text":"<p>Semana de ambienta\u00e7\u00e3o da disciplina. Formamos um grupo e optamos pelo desenvolvimento de um compilador para nosso projeto. </p>"},{"location":"acompanhamento/semana-01/#2-tarefas-realizadas","title":"2. Tarefas Realizadas","text":"<ul> <li> Cria\u00e7\u00e3o de Reposit\u00f3rio: um reposit\u00f3rio foi criado para desenvolver e documentar o projeto.</li> <li> Deploy de GitHub Pages: deploy de branch espec\u00edfica para cria\u00e7\u00e3o de site com a documenta\u00e7\u00e3o do projeto. </li> <li> Configura\u00e7\u00e3o de ambiente de desenvolvimento: utilizando o roteiro disponibilizado pelo professor, configuramos o ambiente de desenvolvimento com as ferramentas necess\u00e1rias para o desenvolvimento de um compilador.</li> </ul>"},{"location":"acompanhamento/semana-01/#3-problemas-e-desafios","title":"3. Problemas e Desafios","text":"<ul> <li>Configura\u00e7\u00e3o de ambiente no Windows: os participantes relataram dificuldades para configurar o ambiente no Windows.</li> </ul>"},{"location":"acompanhamento/semana-01/#4-proximos-passos","title":"4. Pr\u00f3ximos Passos","text":"<ul> <li>Come\u00e7ar a estudar compiladores</li> <li>Decidir linguagens abordadas no projeto</li> <li>Fazer cronograma</li> <li>Definir SCRUM Master</li> <li>Estabelecer regras e boas pr\u00e1ticas para o projeto</li> </ul>"},{"location":"acompanhamento/semana-01/#5-historico-de-versoes","title":"5. Hist\u00f3rico de Vers\u00f5es","text":"<p>A Tabela 1 registra o hist\u00f3rico de vers\u00e3o desse documento.</p> Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor 27/03/2025 1.0 Primeira Vers\u00e3o do artefato da Semana 01 Brunna -  Tabela 1: Hist\u00f3rico de Vers\u00f5es  Autor(es): Brunna  Fonte: Autor(es)"},{"location":"acompanhamento/semana-02/","title":"Semana 2","text":""},{"location":"acompanhamento/semana-02/#1-resumo-da-semana","title":"1. Resumo da Semana","text":"<p>Semana em que iniciamos os estudos em compiladores.</p>"},{"location":"acompanhamento/semana-02/#2-tarefas-realizadas","title":"2. Tarefas Realizadas","text":"<ul> <li> Linguagem dos Compiladores: o grupo decidiu que o compilador ser\u00e1 da linguagem Python para C.</li> <li> Exerc\u00edcio em sala: desenvolvemos o exerc\u00edcio proposto em sala, que a partir de um compilador que reconhecia n\u00fameros inteiros, dever\u00edamos aprimor\u00e1-lo para reconhecer identificadores. Clique aqui para acessar a pasta com o c\u00f3digo.</li> </ul>"},{"location":"acompanhamento/semana-02/#3-problemas-e-desafios","title":"3. Problemas e Desafios","text":"<ul> <li>O primeiro contato com bison e flex foi dif\u00edcil para o grupo. Apenas o Arthur conseguiu resolver o exerc\u00edcio, e ele ensinou aos demais integrantes do grupo.</li> </ul>"},{"location":"acompanhamento/semana-02/#4-proximos-passos","title":"4. Pr\u00f3ximos Passos","text":"<ul> <li>Estudar mais sobre flex e bison.</li> <li>Iniciar o projeto.</li> </ul>"},{"location":"acompanhamento/semana-02/#5-historico-de-versoes","title":"5. Hist\u00f3rico de Vers\u00f5es","text":"<p>A Tabela 1 registra o hist\u00f3rico de vers\u00e3o desse documento.</p> Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor 02/04/2025 1.0 Primeira Vers\u00e3o do artefato da Semana 02 Brunna -  Tabela 1: Hist\u00f3rico de Vers\u00f5es  Autor(es): Brunna  Fonte: Autor(es)"},{"location":"analisadores/analisador-lexico/","title":"Hist\u00f3rico de Vers\u00f5es","text":"Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor dd/mm/yyyy 1.0 - - -"},{"location":"analisadores/analisador-semantico/","title":"Hist\u00f3rico de Vers\u00f5es","text":"Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor dd/mm/yyyy 1.0 - - -"},{"location":"analisadores/analisador-sintatico/","title":"Hist\u00f3rico de Vers\u00f5es","text":"Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor dd/mm/yyyy 1.0 - - -"},{"location":"entrega1/cronograma/","title":"3. Cronograma de sprints","text":""},{"location":"entrega1/cronograma/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>O objetivo do cronograma \u00e9 organizar a equipe em rela\u00e7\u00e3o as entregas durante o desenvolvimento do compilador. Sendo assim, atrav\u00e9s da metodologia Scrum, constru\u00edmos um cronograma com esse objetivo.</p>"},{"location":"entrega1/cronograma/#planejamento-da-equipe","title":"Planejamento da Equipe","text":"<p>Na tabela 1 abaixo, est\u00e3o descritas a enumera\u00e7\u00e3o de sprint, suas dura\u00e7\u00f5es, os pontos de controle(entregas), objetivos, resultados esperados e a pessoa respons\u00e1vel pelo acompanhamento semanal. Dessa forma, ser\u00e1 poss\u00edvel visualizar de maneira mais clara as atividades que deveremos fazer na semana e como se organizar.</p> Sprints Dura\u00e7\u00e3o Pontos de controle Objetivos Resultado esperado Respons\u00e1vel pelo acompanhamento semanal 1 24/03-28/03 Montar a equipe e configurar ambiente de desenvolvimento Equipe montada e ambiente de desenvolvimento da maioria dos integrantes funcionando Brunna 2 31/03-04/04 Definir o compilador e suas linguagens (Python \u2192 C) Ambiente funcionando para todos; linguagens definidas Brunna 3 07/04-11/04 Definir issues principais do analisador l\u00e9xico e documentar o projeto Documenta\u00e7\u00e3o inicial pronta (escopo, linguagem escolhida, justificativas) Arthur 4 14/04-18/04 Finalizar analisador l\u00e9xico e documenta\u00e7\u00f5es do P1 Issues do l\u00e9xico conclu\u00eddas; in\u00edcio do sint\u00e1tico Genilson 5 21/04-25/04 Desenvolver analisador sint\u00e1tico (atribui\u00e7\u00f5es, fun\u00e7\u00f5es, condicionais, indenta\u00e7\u00e3o) Continua\u00e7\u00e3o do analisador sint\u00e1tico La\u00eds fim de semana 25/04-28/04 P1 Ajustes finais e prepara\u00e7\u00e3o para a apresenta\u00e7\u00e3o do P1 Compilador pronto para demonstra\u00e7\u00e3o b\u00e1sica Mariana 6 28/04-02/05 Avan\u00e7ar no analisador sint\u00e1tico (express\u00f5es, operadores, estruturas de repeti\u00e7\u00e3o b\u00e1sicas) Sint\u00e1tico lidando com mais constru\u00e7\u00f5es da linguagem Taynara 7 05/05-09/05 Iniciar an\u00e1lise sem\u00e2ntica b\u00e1sica (verifica\u00e7\u00e3o de tipos e escopo) Valida\u00e7\u00e3o de tipos e vari\u00e1veis implementada Arthur 8 12/05-16/05 Continuar an\u00e1lise sem\u00e2ntica e tratar erros (vari\u00e1veis n\u00e3o declaradas, tipos incompat\u00edveis) Erros sem\u00e2nticos b\u00e1sicos detectados Brunna 9 19/05-23/05 In\u00edcio da gera\u00e7\u00e3o de c\u00f3digo C (tradu\u00e7\u00e3o b\u00e1sica de estruturas) Primeiros c\u00f3digos C sendo gerados a partir da \u00e1rvore sint\u00e1tica Genilson 10 26/05-30/05 Avan\u00e7ar na gera\u00e7\u00e3o de c\u00f3digo C (tratando mais casos e ajustes) Sa\u00edda em C funcionando para programas pequenos La\u00eds fim de semana 30/05-02/06 P2 Prepara\u00e7\u00e3o e entrega do P2 (avan\u00e7o da an\u00e1lise sem\u00e2ntica e primeira gera\u00e7\u00e3o de c\u00f3digo) x Mariana 11 02/06-06/06 Corre\u00e7\u00f5es p\u00f3s-P2 e otimiza\u00e7\u00f5es no compilador Compilador corrigido e mais robusto Taynara 12 09/06-13/06 Testes finais e adi\u00e7\u00e3o de exemplos mais complexos Compilador testado com diversos programas Arthur 13 16/06-20/06 Finaliza\u00e7\u00e3o do projeto e ajustes finos Vers\u00e3o final do compilador pronta Brunna 14 23/06-27/06 Prepara\u00e7\u00e3o dos materiais de entrega final (documenta\u00e7\u00e3o + c\u00f3digo) Projeto preparado para submiss\u00e3o Genilson dia 27/06 Entrega final Submiss\u00e3o oficial do projeto Entrega realizada La\u00eds 15 30/06-04/07 Feedback p\u00f3s-entrega e encerramento Projeto conclu\u00eddo Mariana <p>Tabela 1: Cronograma de planejamento da equipe. (Fonte: Arthur SuaresMariana Let\u00edcia, 2025)</p> <p></p>"},{"location":"entrega1/cronograma/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor 10/04/2025 1.0 Repassando dados Arthur Suares Mariana Let\u00edcia 10/04/2025 1.0 Adicionando introdu\u00e7\u00e3o e planejamento de equipe Mariana Let\u00edcia Arthur Suares"},{"location":"entrega1/decisoes/","title":"4. Decis\u00f5es t\u00e9cnicas","text":""},{"location":"entrega1/decisoes/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor dd/mm/yyyy 1.0 - - -"},{"location":"entrega1/definicao/","title":"1. Introdu\u00e7\u00e3o e Defini\u00e7\u00e3o do Projeto","text":"<p>Este trabalho consiste no desenvolvimento de um compilador capaz de traduzir um subconjunto de programas escritos em Python para c\u00f3digo equivalente em C. Utilizamos Flex (analisador l\u00e9xico) e Bison (analisador sint\u00e1tico) para montar as etapas de an\u00e1lise l\u00e9xica, an\u00e1lise sint\u00e1tica, constru\u00e7\u00e3o de AST e gera\u00e7\u00e3o de c\u00f3digo, consolidando conceitos fundamentais de compiladores em uma aplica\u00e7\u00e3o pr\u00e1tica.</p> <p>A escolha de Python como linguagem-fonte e C como linguagem-alvo se deve \u00e0 familiaridade da equipe com ambas, al\u00e9m de permitir demonstrar, de forma clara e did\u00e1tica, como estruturas de alto n\u00edvel (listas, controle de fluxo, chamadas de fun\u00e7\u00e3o) podem ser traduzidas para um c\u00f3digo de baixo n\u00edvel.</p>"},{"location":"entrega1/definicao/#11-definicao-de-escopo","title":"1.1 Defini\u00e7\u00e3o de Escopo","text":"<p>O compilador a ser desenvolvido ter\u00e1 como escopo a convers\u00e3o de programas Python com estruturas b\u00e1sicas para c\u00f3digos equivalentes em C. Dentre os elementos que o compilador deve reconhecer e processar corretamente, est\u00e3o:</p> <ul> <li>Declara\u00e7\u00e3o e uso de vari\u00e1veis;</li> <li>Operadores aritm\u00e9ticos (adi\u00e7\u00e3o, subtra\u00e7\u00e3o, multiplica\u00e7\u00e3o, divis\u00e3o, etc.);</li> <li>Operadores relacionais (&gt;, &lt;, ==, etc.);</li> <li>Atribui\u00e7\u00f5es;</li> <li>Delimitadores, como par\u00eanteses (, ) e ponto e v\u00edrgula ;;</li> <li>Espa\u00e7os e quebras de linha, que ser\u00e3o devidamente ignorados ou tratados conforme o contexto;</li> <li>Estrutura geral de um programa: l\u00f3gica de programa\u00e7\u00e3o, declara\u00e7\u00e3o de fun\u00e7\u00f5es e procedimentos.</li> </ul> <p>Vale ressaltar que o compilador n\u00e3o tem a inten\u00e7\u00e3o de cobrir todos os recursos avan\u00e7ados da linguagem Python, como orienta\u00e7\u00e3o a objetos, estruturas complexas (como listas, dicion\u00e1rios ou fun\u00e7\u00f5es aninhadas), ou bibliotecas externas. O foco \u00e9 a tradu\u00e7\u00e3o de programas simples e lineares, o que permite uma an\u00e1lise e gera\u00e7\u00e3o de c\u00f3digo mais direta e did\u00e1tica.</p>"},{"location":"entrega1/definicao/#12-implementacao-do-escopo","title":"1.2 Implementa\u00e7\u00e3o do Escopo","text":"<p>O compilador suporta um subconjunto b\u00e1sico de Python, suficiente para escrever pequenos programas funcionais e lineares. Mais exatamente, reconhece e processa:</p> <ul> <li>Declara\u00e7\u00f5es e atribui\u00e7\u00f5es de vari\u00e1veis   \u2014 Inteiros e ponto-flutuante (ex.: <code>x = 42</code>, <code>y = 3.14</code>).  </li> <li>Operadores aritm\u00e9ticos   \u2014 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> com preced\u00eancia correta.  </li> <li>Operadores relacionais e l\u00f3gicos   \u2014 <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, al\u00e9m de <code>and</code>, <code>or</code>, <code>not</code>.  </li> <li>Estruturas de controle de fluxo </li> <li>Condicionais: <code>if ...: [elif ...:] [else ...:]</code> </li> <li>La\u00e7os: <code>while</code> </li> <li>Defini\u00e7\u00e3o e chamada de fun\u00e7\u00f5es   \u2014 Sintaxe <code>def nome(param1, param2):</code> com corpo indentado; chamadas com argumentos posicionais.  </li> <li>Delimitadores e indenta\u00e7\u00e3o   \u2014 Par\u00eanteses <code>(</code> <code>)</code>, dois-pontos <code>:</code>, ponto-v\u00edrgula opcional; indenta\u00e7\u00e3o (INDENT/DEDENT) usada para delimitar blocos.  </li> <li>Coment\u00e1rios e espa\u00e7os em branco   \u2014 Coment\u00e1rios em linha (<code># ...</code>) s\u00e3o ignorados; quebras de linha e espa\u00e7os s\u00e3o tratados conforme a sintaxe Python.</li> </ul> <p>N\u00e3o abrange recursos avan\u00e7ados como orienta\u00e7\u00e3o a objetos, compreens\u00f5es de lista, dicion\u00e1rios, multithreading ou m\u00f3dulos externos.  </p>"},{"location":"entrega1/definicao/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor 11/04/2025 1.0 Vers\u00e3o inicial da introdu\u00e7\u00e3o e defini\u00e7\u00e3o de escopo do projeto. Brunna Louise Genilson Silva 27/06/2025 1.1 Documenta\u00e7\u00e3o atualizada para refletir estado atual do c\u00f3digo. Genilson Silva"},{"location":"entrega1/desafios/","title":"5. Desafios encontrados pela equipe","text":""},{"location":"entrega1/desafios/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor dd/mm/yyyy 1.0 - - -"},{"location":"entrega1/linguagem/","title":"2. Liguagens de programa\u00e7\u00e3o escolhida pelo grupo","text":"<p>Para o desenvolvimento da constru\u00e7\u00e3o de um compilador, o grupo escolheu as linguagens Python e C. O compilador transformar\u00e1 c\u00f3digo escrito em Python para a linguagem C.</p>"},{"location":"entrega1/linguagem/#21-motivacao","title":"2.1 Motiva\u00e7\u00e3o","text":"<p>A decis\u00e3o se baseou no fato de que ambas as linguagens s\u00e3o conhecidas pelos integrantes do grupo, o que facilita o desenvolvimento. Al\u00e9m disso, a escolha da convers\u00e3o de Python para C se justifica pela busca por um melhor desempenho na execu\u00e7\u00e3o dos programas, j\u00e1 que a linguagem C apresenta maior efici\u00eancia em tempo de execu\u00e7\u00e3o e uso de recursos.</p>"},{"location":"entrega1/linguagem/#22-linguagem-python","title":"2.2 Linguagem Python","text":"<p>Python \u00e9 uma linguagem de programa\u00e7\u00e3o de alto n\u00edvel, interpretada e de prop\u00f3sito geral. Ela \u00e9 amplamente utilizada devido \u00e0 sua sintaxe simples e legibilidade, o que facilita o aprendizado e o desenvolvimento r\u00e1pido de aplica\u00e7\u00f5es. Python possui uma vasta biblioteca padr\u00e3o e suporte a diversos paradigmas de programa\u00e7\u00e3o, como orienta\u00e7\u00e3o a objetos, funcional e imperativa. \u00c9 frequentemente usada em \u00e1reas como desenvolvimento web, ci\u00eancia de dados, intelig\u00eancia artificial e automa\u00e7\u00e3o.</p>"},{"location":"entrega1/linguagem/#23-linguagem-c","title":"2.3 Linguagem C","text":"<p>C \u00e9 uma linguagem de programa\u00e7\u00e3o de baixo n\u00edvel, compilada e amplamente utilizada para o desenvolvimento de sistemas e aplica\u00e7\u00f5es que exigem alto desempenho. Ela \u00e9 conhecida por sua efici\u00eancia, controle direto sobre o hardware e uso otimizado de recursos. C \u00e9 frequentemente empregada em sistemas operacionais, drivers, softwares embarcados e outras \u00e1reas onde o desempenho \u00e9 cr\u00edtico. Sua sintaxe influenciou diversas linguagens modernas, tornando-a uma base importante no aprendizado de programa\u00e7\u00e3o.</p>"},{"location":"entrega1/linguagem/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor 17/04/2025 1.0 Defini\u00e7\u00e3o das linguagens de programa\u00e7\u00e3o escolhidas grupo La\u00eds Ramos Barbosa e Taynara Cristina Ribeiro Marcellos -"},{"location":"entrega1/solucoes/","title":"6. Solu\u00e7\u00f5es encontradas pela equipe","text":""},{"location":"entrega1/solucoes/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor dd/mm/yyyy 1.0 - - -"},{"location":"entrega1/analisador-lexico/controle-identacao/","title":"Controle de Indenta\u00e7\u00e3o (INDENT/DEDENT)","text":"<p>Para emular a estrutura de blocos de linguagens como Python, o analisador l\u00e9xico implementa um mecanismo sofisticado para controlar os n\u00edveis de indenta\u00e7\u00e3o do c\u00f3digo-fonte. Em vez de usar delimitadores como {} para definir o escopo de fun\u00e7\u00f5es, la\u00e7os e condicionais, o compilador utiliza a varia\u00e7\u00e3o no n\u00famero de espa\u00e7os ou tabula\u00e7\u00f5es no in\u00edcio de cada linha para gerar os tokens INDENT e DEDENT.</p>"},{"location":"entrega1/analisador-lexico/controle-identacao/#tokens-de-indentacao","title":"Tokens de Indenta\u00e7\u00e3o","text":"<p>A Tabela 1 descreve os tokens gerados pelo mecanismo de controle de indenta\u00e7\u00e3o.</p> Token Express\u00e3o regular correspondente Descri\u00e7\u00e3o INDENT ^[ \\t]+ (contextual) Gerado quando a indenta\u00e7\u00e3o de uma nova linha \u00e9 maior que a da linha anterior, indicando o in\u00edcio de um novo bloco de escopo. DEDENT ^[ \\t]+ (contextual) ou ~ Gerado quando a indenta\u00e7\u00e3o de uma nova linha \u00e9 menor que a da linha anterior, indicando o fim de um ou mais blocos de escopo. O token ~ tamb\u00e9m pode ser usado para disparar um DEDENT manualmente. NEWLINE \\r?\\n Gerado ao final de uma linha de c\u00f3digo, sendo fundamental para a l\u00f3gica de indenta\u00e7\u00e3o e para a separa\u00e7\u00e3o de statements no analisador sint\u00e1tico. <p>Tabela 1: Tokens de controle de indenta\u00e7\u00e3o. (Fonte: Brunna Louise, 2025)</p>"},{"location":"entrega1/analisador-lexico/controle-identacao/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor 27/06/2025 1.0 Cria\u00e7\u00e3o do documento de controle de identa\u00e7\u00e3o no lexer Brunna Louise -"},{"location":"entrega1/analisador-lexico/identificadores-palavras-chave/","title":"Identificadores e Palavras-chave","text":""},{"location":"entrega1/analisador-lexico/identificadores-palavras-chave/#tokens","title":"Tokens","text":"<p>Segue abaixo a Tabela 1 contendo os tokens referentes aos identificadores e palavras-chave utilizados no compilador, al\u00e9m de suas express\u00f5es regulares e descri\u00e7\u00f5es. A escolha desses elementos foi baseada nas palavras-chave pr\u00f3pria da linguagem escolhida bem como na estrutura de identificadorres proposta pelo compiador:</p> <p></p> Token Express\u00e3o regular correspondente Campo yyval Descri\u00e7\u00e3o ID <code>[a-zA-Z_][a-zA-Z0-9_]*</code> str Designado a identifica\u00e7\u00e3o de identificadores IF <code>\"if\"</code> -- Token usado para identificar a palavra-chave if ELSE <code>\"else\"</code> -- Token usado para identificar a palavra-chave else ELIF <code>\"elif\"</code> -- Token usado para identificar a palavra-chave elif WHILE <code>\"while\"</code> -- Token usado para identificar a palavra-chave  while FOR <code>\"for\"</code> -- Token usado para identificar a palavra-chave for DEF <code>\"def\"</code> -- Token usado para identificar a palavra-chave def  RETURN <code>\"return\"</code> -- Token usado para identificar a palavra-chave return IN <code>\"in\"</code> -- Token usado para identificar a palavra-chave in TRUE <code>\"true\"</code> -- Token usado para identificar a palavra-chave true FALSE <code>\"false\"</code> -- Token usado para identificar a palavra-chave false AND <code>\"and\"</code> -- Token usado para identificar a palavra-chave and OR <code>\"or\"</code> -- Token usado para identificar a palavra-chave or NOT <code>\"not\"</code> -- Token usado para identificar a palavra-chave not CLASS <code>\"class\"</code> -- Token usado para identificar a palavra-chave class IMPORT <code>\"import\"</code> -- Token usado para identificar a palavra-chave import FROM <code>\"from\"</code> -- Token usado para identificar a palavra-chave from AS <code>\"as\"</code> -- Token usado para identificar a palavra-chave as TRY <code>\"try\"</code> -- Token usado para identificar a palavra-chave try EXCEPT <code>\"except\"</code> -- Token usado para identificar a palavra-chave except FINALLY <code>\"finally\"</code> -- Token usado para identificar a palavra-chave finally WITH <code>\"with\"</code> -- Token usado para identificar a palavra-chave with PASS <code>\"pass\"</code> -- Token usado para identificar a palavra-chave pass BREAK <code>\"break\"</code> -- Token usado para identificar a palavra-chave break CONTINUE <code>\"continue\"</code> -- Token usado para identificar a palavra-chave continue GLOBAL <code>\"global\"</code> -- Token usado para identificar a palavra-chave global NONLOCAL <code>\"nonlocal\"</code> -- Token usado para identificar a palavra-chave nonlocal LAMBDA <code>\"lambda\"</code> -- Token usado para identificar a palavra-chave lambda <p>Tabela 1: Tokens e suas respectivas express\u00f5es regulares. (Fonte: La\u00eds Ramos e Taynara Cristina, 2025)</p>"},{"location":"entrega1/analisador-lexico/identificadores-palavras-chave/#decisoes-tecnicas","title":"Decis\u00f5es t\u00e9cnicas","text":"<p>Foram listadas todas as palavras-chave desconhecidas, e realizada uma pesquisa online para compreender e identificar termos t\u00e9cnicos que n\u00e3o eram de conhecimento da equipe.</p>"},{"location":"entrega1/analisador-lexico/identificadores-palavras-chave/#desafios-encontradas","title":"Desafios Encontradas","text":"<ul> <li>Escassez de materiais sobre a tecnologia Bison.</li> <li>Interface do Bison pouco intuitiva, dificultando o entendimento de seu funcionamento.</li> <li>Dificuldade em identificar qual seria o resultado esperado para as entradas fornecidas.</li> </ul>"},{"location":"entrega1/analisador-lexico/identificadores-palavras-chave/#solucoes-adotadas","title":"Solu\u00e7\u00f5es Adotadas","text":"<ul> <li>Realiza\u00e7\u00e3o de an\u00e1lise detalhada das palavras-chave, considerando tamb\u00e9m casos de borda para validar o comportamento esperado.</li> <li>Utiliza\u00e7\u00e3o das sa\u00eddas do terminal para acompanhar e verificar se os resultados obtidos estavam alinhados \u00e0s expectativas.</li> </ul>"},{"location":"entrega1/analisador-lexico/identificadores-palavras-chave/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor 28/04/2025 1.0 Cria\u00e7\u00e3o do documento e inclus\u00e3o de informa\u00e7\u00f5es sobre decis\u00f5es, desafios e solu\u00e7\u00f5es La\u00eds Ramos Barbosa 170107574 28/04/2025 1.0 Cria\u00e7\u00e3o do documento e inclus\u00e3o de informa\u00e7\u00f5es sobre decis\u00f5es, desafios e solu\u00e7\u00f5es Taynara Cristina Ribeiro Marcellos 211031833"},{"location":"entrega1/analisador-lexico/literais-comentarios/","title":"Literais e Coment\u00e1rios","text":""},{"location":"entrega1/analisador-lexico/literais-comentarios/#tokens","title":"Tokens","text":"<p>Segue abaixo a Tabela 1 contendo os tokens utilizados no compilador, al\u00e9m de suas express\u00f5es regulares e descri\u00e7\u00f5es. Essess tokens foram utilizados para representarem unidades l\u00e9xicas, utilizados tamb\u00e9m como a menor elemento que \u00e9 significativo para o compilador. Sendo assim, pensando em um conjunto de opera\u00e7\u00f5es matem\u00e1ticas, strings e opera\u00e7\u00f5es da l\u00f3gica da programa\u00e7\u00e3o, optamos por selecionar os seguintes tokens:</p> <p></p> Token Express\u00e3o regular correspondente Campo yyval Descri\u00e7\u00e3o NUMBER <code>[0-9]+ ou [0-9]+\\.[0-9]+</code> numero Token gen\u00e9rico para literais num\u00e9ricos. O campo yylval.numero armazena uma struct Numero que cont\u00e9m o tipo (TIPO_INT ou TIPO_FLOAT) e o valor j\u00e1 convertido. STRING_LITERAL <code>`\"([^\"\\]</code> <code>\\.)*\"\\'([^'\\] Designado a identifica\u00e7\u00e3o de strings. <p>Tabela 1: Tokens e suas respectivas express\u00f5es regulares. (Fonte: Mariana Let\u00edcia e Brunna Louise, 2025)</p>"},{"location":"entrega1/analisador-lexico/literais-comentarios/#comentarios","title":"Coment\u00e1rios","text":"<p>Coment\u00e1rios s\u00e3o elementos fundamentais para organiza\u00e7\u00e3o e documenta\u00e7\u00e3o, mas seu conte\u00fado n\u00e3o \u00e9 relevante para a compila\u00e7\u00e3o. Portanto, eles s\u00e3o identificados e completamente ignorados pelo analisador l\u00e9xico.</p> Tipo de coment\u00e1rio Express\u00e3o regular correspondente Descri\u00e7\u00e3o Coment\u00e1rio de Linha <code>\"#\".*</code> Ignora todo o texto desde o caractere # at\u00e9 o final da linha. <p>Tabela 2:  Tipos de coment\u00e1rios ignorados. (Fonte: Mariana Let\u00edcia e Brunna Louise, 2025)</p>"},{"location":"entrega1/analisador-lexico/literais-comentarios/#decisoes-tecninas-tomadas","title":"Decis\u00f5es t\u00e9cninas tomadas","text":""},{"location":"entrega1/analisador-lexico/literais-comentarios/#tratamento-de-literais-numericos","title":"Tratamento de Literais Num\u00e9ricos","text":"<p>Durante a implementa\u00e7\u00e3o, foi decidido que o analisador l\u00e9xico faria mais do que apenas identificar o texto de um n\u00famero. Para otimizar o trabalho do analisador sint\u00e1tico, o lexer j\u00e1 converte o texto (yytext) para seu valor num\u00e9rico (int ou float) e o armazena, junto com seu tipo, em uma <code>struct Numero</code>. Essa estrutura \u00e9 ent\u00e3o passada para o parser atrav\u00e9s do campo <code>yylval.numero</code>. Esta abordagem centraliza a l\u00f3gica de convers\u00e3o e simplifica as regras sint\u00e1ticas.</p> <p>Ambiguidade entre Strings Multilinha e Coment\u00e1rios Uma caracter\u00edstica da linguagem Python \u00e9 que uma string literal que n\u00e3o \u00e9 atribu\u00edda a uma vari\u00e1vel pode funcionar como um coment\u00e1rio de bloco. O desafio era decidir como tratar isso.</p> <p>A decis\u00e3o tomada foi: o analisador l\u00e9xico sempre tratar\u00e1 sequ\u00eancias entre aspas triplas como <code>STRING_LITERAL</code>. Ele n\u00e3o tem contexto para saber se a string ser\u00e1 usada ou n\u00e3o. O lexer se encarrega de normalizar a string (removendo as aspas triplas) e a envia para o analisador sint\u00e1tico.</p> <p>Caber\u00e1 ao analisador sint\u00e1tico, com base em suas regras gramaticais, decidir o que fazer com esse <code>STRING_LITERAL</code>: se ele far\u00e1 parte de uma atribui\u00e7\u00e3o, de um print, ou se deve ser ignorado (funcionando, na pr\u00e1tica, como um coment\u00e1rio).</p>"},{"location":"entrega1/analisador-lexico/literais-comentarios/#desafios-encontrados","title":"Desafios Encontrados","text":"<p>Os principais desafios encontrados foram:</p> <p>Entender as estruturas b\u00e1sicas de um compilador e como o analisador l\u00e9xico e sint\u00e1tico se comunicam.</p> <p>Lidar com a ambiguidade de strings multilinha, que podem ser tanto valores de dados quanto coment\u00e1rios de bloco, dependendo do contexto sint\u00e1tico.</p> <p>Definir uma forma eficiente de passar dados ricos (como um n\u00famero j\u00e1 convertido e tipado) do l\u00e9xico para o sint\u00e1tico, em vez de apenas texto.</p>"},{"location":"entrega1/analisador-lexico/literais-comentarios/#solucoes-adotadas","title":"Solu\u00e7\u00f5es Adotadas","text":"<p>Para a comunica\u00e7\u00e3o entre as ferramentas, foram estudados exemplos e utilizada a estrutura de tokens padr\u00e3o, onde o <code>lexer.l</code> retorna identificadores de token que o <code>parser.y</code> espera.</p> <p>A solu\u00e7\u00e3o para a ambiguidade foi delegar a responsabilidade: o lexer identifica <code>STRING_LITERAL</code> de forma agn\u00f3stica, e o parser decide seu destino.</p> <p>Para passar dados ricos, a solu\u00e7\u00e3o foi utilizar a diretiva <code>%union</code> no <code>parser.y</code>. Isso permitiu definir um tipo yylval capaz de armazenar diferentes tipos de valores, incluindo a <code>struct Numero</code> para literais num\u00e9ricos e ponteiros de char* para strings, tornando a gram\u00e1tica mais limpa e poderosa.</p>"},{"location":"entrega1/analisador-lexico/literais-comentarios/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor 13/04/2025 1.0 Adicionando Tokens literais e de coment\u00e1rio Mariana Let\u00edcia Arthur Suares 17/04/2025 1.1 Adicionando explica\u00e7\u00e3o das decis\u00f5es t\u00e9cnicas Arthur Suares Mariana Let\u00edcia 20/04/2025 1.2 Adicionando desafios e solu\u00e7\u00f5es encontrados Arthur Suares e Mariana Let\u00edcia Mariana Let\u00edcia 27/06/2025 1.3 Atualizando documenta\u00e7\u00e3o para refletir o atual estado do c\u00f3digo Brunna Louise -"},{"location":"entrega1/analisador-lexico/operadores-delimitadores-erros/","title":"Operadores, Delimitadores e Erros","text":""},{"location":"entrega1/analisador-lexico/operadores-delimitadores-erros/#tokens","title":"Tokens","text":"<p>Neste compilador, foram considerados operadores aritm\u00e9ticos, relacionais, de atribui\u00e7\u00e3o e delimitadores de escopo. A escolha desses elementos foi baseada nas constru\u00e7\u00f5es comuns da linguagem Python. A Tabela 1 abaixo detalha os tokens gerados para cada um desses elementos.</p> <p></p> Token Express\u00e3o regular correspondente Campo yyval Descri\u00e7\u00e3o PLUS <code>\"+\"</code> -- Token usado durante opera\u00e7\u00f5es de soma MINUS <code>\"-\"</code> -- Token usado para opera\u00e7\u00f5es de subtra\u00e7\u00e3o TIMES <code>\"*\"</code> -- Token usado para opera\u00e7\u00f5es de multiplica\u00e7\u00e3o DIVIDE <code>\"/\"</code> -- Token usado para opera\u00e7\u00f5es de divis\u00e3o MODULO <code>\"%\"</code> -- Token usado para obter o quociente de uma divis\u00e3o LPAREN <code>\"(\"</code> -- Token usado para abrir par\u00eanteses RPAREN <code>\")\"</code> -- Token usado para fechar par\u00eanteses LBRACKET <code>\"[\"</code> -- Token usado para abrir colchetes RBRACKET <code>\"]\"</code> -- Token usado para fechar colchetes LBRACE <code>\"{\"</code> -- Token usado para abrir chaves RBRACE <code>\"}\"</code> -- Token usado para fechar chaves COMMA <code>\",\"</code> -- Token usado para separar argumentos chamados em uma fun\u00e7\u00e3o COLON <code>\":\"</code> -- Token usado para delimitar in\u00edcio de um procedimento, fun\u00e7\u00e3o, loops ou condicionais DOT <code>\".\"</code> -- Token usado para chamada de fun\u00e7\u00f5es SEMICOLON <code>\";\"</code> -- Token usado para delimitar escopo ASSIGN <code>\"=\"</code> -- Token usado para atribui\u00e7\u00e3o EQTO <code>\"==\"</code> -- Token usado para comparar a igualdade entre dois valores NOTEQTO <code>\"!=\"</code> -- Token usado para comparar a diferen\u00e7a entre dois valores PLUSEQ <code>\"+=\"</code> -- Token para o operador de atribui\u00e7\u00e3o de soma. MINUSEQ <code>\"-=\"</code> --  Token para o operador de atribui\u00e7\u00e3o de subtra\u00e7\u00e3o. LESSER <code>\"&lt;\"</code> -- Token usado para verificar se o argumento da esquerda \u00e9 menor que o argumento da direita GREATER <code>\"&gt;\"</code> -- Token usado para verificar se o argumento da esquerda \u00e9 maior que o argumento da direita LESSEQ <code>\"&lt;=&lt;\"</code> -- Token usado para verificar se o argumento da esquerda \u00e9 menor ou igual ao argumento da direita GREATEQ <code>\"&gt;=\"</code> -- Token usado para verificar se o argumento da esquerda \u00e9 maior ou igual ao argumento da direita <p>Tabela 1: Tokens e suas respectivas express\u00f5es regulares. (Fonte: Brunna Louise, 2025)</p> <p>Com certeza! Analisei a se\u00e7\u00e3o \"Operadores, Delimitadores e Erros\" e comparei com seu <code>lexer.l</code> atual.</p> <p>A boa not\u00edcia \u00e9 que a maior parte da documenta\u00e7\u00e3o est\u00e1 correta. As principais atualiza\u00e7\u00f5es necess\u00e1rias s\u00e3o:</p> <ol> <li>Tabela de Tokens Incompleta: Faltam os operadores de atribui\u00e7\u00e3o composta (<code>+=</code>, <code>-=</code>) que existem no seu c\u00f3digo. Al\u00e9m disso, h\u00e1 um pequeno erro de digita\u00e7\u00e3o na express\u00e3o regular de um dos operadores.</li> <li>Tratamento de Erros Desatualizado: A sua documenta\u00e7\u00e3o descreve um sistema de tratamento de erros que retorna um token <code>ERROR</code> e usa uma vari\u00e1vel global <code>linha</code>. Seu c\u00f3digo atual \u00e9 mais simples: ele apenas imprime o \"Caractere inv\u00e1lido\" e continua, usando a vari\u00e1vel <code>yylineno</code> (que \u00e9 autom\u00e1tica do Flex).</li> <li>Inconsist\u00eancia no C\u00f3digo de Exemplo: O trecho de c\u00f3digo na se\u00e7\u00e3o \"Decis\u00f5es T\u00e9cnicas\" est\u00e1 diferente do seu arquivo <code>lexer.l</code> real (usa <code>EQUAL</code> em vez de <code>ASSIGN</code>).</li> </ol> <p>Preparei a se\u00e7\u00e3o inteira com as corre\u00e7\u00f5es e atualiza\u00e7\u00f5es. Assim como da \u00faltima vez, o mais f\u00e1cil e seguro \u00e9 substituir toda a se\u00e7\u00e3o, desde o t\u00edtulo <code># Operadores, Delimitadores e Erros</code> at\u00e9 o final do hist\u00f3rico de vers\u00f5es dela.</p>"},{"location":"entrega1/analisador-lexico/operadores-delimitadores-erros/#documentacao-atualizada","title":"Documenta\u00e7\u00e3o Atualizada","text":""},{"location":"entrega1/analisador-lexico/operadores-delimitadores-erros/#operadores-delimitadores-e-erros_1","title":"Operadores, Delimitadores e Erros","text":""},{"location":"entrega1/analisador-lexico/operadores-delimitadores-erros/#tokens_1","title":"Tokens","text":"<p>Neste compilador, foram considerados operadores aritm\u00e9ticos, relacionais, de atribui\u00e7\u00e3o e delimitadores de escopo. A escolha desses elementos foi baseada nas constru\u00e7\u00f5es comuns da linguagem Python. A Tabela 1 abaixo detalha os tokens gerados para cada um desses elementos.</p> <p>\\&lt;br&gt;</p> <p>\\&lt;center&gt;</p> Token Express\u00e3o regular correspondente Campo yyval Descri\u00e7\u00e3o <code>PLUS</code> <code>\"+\"</code> -- Token para o operador de soma. <code>MINUS</code> <code>\"-\"</code> -- Token para o operador de subtra\u00e7\u00e3o. <code>TIMES</code> <code>\"*\"</code> -- Token para o operador de multiplica\u00e7\u00e3o. <code>DIVIDE</code> <code>\"/\"</code> -- Token para o operador de divis\u00e3o. <code>MODULO</code> <code>\"%\"</code> -- Token para o operador de m\u00f3dulo (resto da divis\u00e3o). <code>ASSIGN</code> <code>\"=\"</code> -- Token para o operador de atribui\u00e7\u00e3o simples. <code>PLUSEQ</code> <code>\"+=\"</code> -- Token para o operador de atribui\u00e7\u00e3o de soma. <code>MINUSEQ</code> <code>\"-=\"</code> -- Token para o operador de atribui\u00e7\u00e3o de subtra\u00e7\u00e3o. <code>EQTO</code> <code>\"==\"</code> -- Token para o operador relacional de igualdade. <code>NOTEQTO</code> <code>\"!=\"</code> -- Token para o operador relacional de diferen\u00e7a. <code>LESSER</code> <code>\"&lt;\"</code> -- Token para o operador relacional \"menor que\". <code>GREATER</code> <code>\"&gt;\"</code> -- Token para o operador relacional \"maior que\". <code>LESSEQ</code> <code>\"&lt;=\"</code> -- Token para o operador relacional \"menor ou igual a\". <code>GREATEQ</code> <code>\"&gt;=\"</code> -- Token para o operador relacional \"maior ou igual a\". <code>LPAREN</code> <code>\"(\"</code> -- Delimitador: abre par\u00eanteses. <code>RPAREN</code> <code>\")\"</code> -- Delimitador: fecha par\u00eanteses. <code>LBRACKET</code> <code>\"[\"</code> -- Delimitador: abre colchetes. <code>RBRACKET</code> <code>\"]\"</code> -- Delimitador: fecha colchetes. <code>LBRACE</code> <code>\"{</code> -- Delimitador: abre chaves. <code>RBRACE</code> <code>\"}\"</code> -- Delimitador: fecha chaves. <code>COLON</code> <code>\":\"</code> -- Delimitador: dois pontos, usado em <code>if</code>, <code>def</code>, etc. <code>COMMA</code> <code>\",\"</code> -- Delimitador: v\u00edrgula, usada para separar itens. <code>DOT</code> <code>\".\"</code> -- Delimitador: ponto, usado para acesso a atributos. <code>SEMICOLON</code> <code>\";\"</code> -- Delimitador: ponto e v\u00edrgula. <p>\\&lt;p align=\"center\"&gt;\\&lt;em&gt;Tabela 1: Tokens de operadores e delimitadores. (Fonte: \\&lt;a href=\"https://github.com/brunna-martins\"&gt;Brunna Louise\\&lt;/a&gt;, 2025)\\&lt;/em&gt;\\&lt;/p&gt;</p> <p>\\&lt;/center&gt;</p>"},{"location":"entrega1/analisador-lexico/operadores-delimitadores-erros/#decisoes-tecnicas","title":"Decis\u00f5es T\u00e9cnicas","text":""},{"location":"entrega1/analisador-lexico/operadores-delimitadores-erros/#ordem-das-regras-de-operadores","title":"Ordem das Regras de Operadores","text":"<p>Durante a implementa\u00e7\u00e3o, foi crucial ordenar as regras para que os operadores compostos (como <code>==</code>, <code>+=</code>, <code>&lt;=</code>) aparecessem antes de seus componentes simples (<code>=</code>, <code>+</code>, <code>&lt;</code>). Como o Flex adota a estrat\u00e9gia de \"maior casamento\" (longest match), essa ordena\u00e7\u00e3o garante que <code>+=</code> seja reconhecido como um \u00fanico token <code>PLUSEQ</code>, em vez de um <code>PLUS</code> seguido por um <code>ASSIGN</code>.</p> <pre><code>// Correto: operador composto primeiro\n\"==\"      { return EQTO; }\n\"=\"       { return ASSIGN; }\n\n// Incorreto: \"=\" seria reconhecido antes de \"==\"\n// \"=\"       { return ASSIGN; } \n// \"==\"      { return EQTO; }\n</code></pre>"},{"location":"entrega1/analisador-lexico/operadores-delimitadores-erros/#tratamento-de-erros-lexicos","title":"Tratamento de Erros L\u00e9xicos","text":"<p>Para o tratamento de erros, foi adotada uma abordagem simples e direta. Uma regra \"pega-tudo\" (<code>.</code>) foi posicionada ao final do arquivo de regras do lexer.</p> <pre><code>// Regra no final de lexer.l\n.         { printf(\"Caractere inv\u00e1lido: %s\\n\", yytext); }\n</code></pre> <p>Qualquer caractere no c\u00f3digo-fonte que n\u00e3o case com nenhuma das regras de tokens definidas anteriormente (palavras-chave, identificadores, n\u00fameros, operadores, etc.) ser\u00e1 capturado por esta regra.</p> <p>A decis\u00e3o foi n\u00e3o parar a execu\u00e7\u00e3o. Em vez disso, o lexer simplesmente imprime uma mensagem de erro no console, informando qual foi o caractere inv\u00e1lido (<code>yytext</code>), e continua a an\u00e1lise do restante do arquivo. Para a numera\u00e7\u00e3o da linha, o lexer utiliza a vari\u00e1vel <code>yylineno</code>, que \u00e9 mantida e incrementada automaticamente pelo Flex, garantindo precis\u00e3o na localiza\u00e7\u00e3o do erro sem a necessidade de uma vari\u00e1vel global customizada.</p>"},{"location":"entrega1/analisador-lexico/operadores-delimitadores-erros/#desafios-encontrados","title":"Desafios Encontrados","text":"<p>O principal desafio foi garantir que o tratamento de erros fosse informativo, mas n\u00e3o interrompesse a an\u00e1lise l\u00e9xica prematuramente. A ideia \u00e9 permitir que o compilador reporte o m\u00e1ximo de erros l\u00e9xicos poss\u00edvel em uma \u00fanica execu\u00e7\u00e3o, em vez de parar no primeiro.</p> <p>Outro ponto de aten\u00e7\u00e3o foi a correta defini\u00e7\u00e3o da preced\u00eancia dos operadores para evitar ambiguidades, como o caso de <code>=</code> vs. <code>==</code>.</p>"},{"location":"entrega1/analisador-lexico/operadores-delimitadores-erros/#solucoes-adotadas","title":"Solu\u00e7\u00f5es Adotadas","text":"<p>A solu\u00e7\u00e3o para a preced\u00eancia foi a ordena\u00e7\u00e3o cuidadosa das regras no arquivo <code>.l</code>, conforme mencionado.</p> <p>Para o tratamento de erros, a solu\u00e7\u00e3o foi a regra <code>.</code> no final do arquivo. Ela funciona como um \"else\" final no reconhecimento de tokens, provendo um feedback imediato sobre caracteres inesperados sem a complexidade de retornar tokens de erro espec\u00edficos e exigir que o parser os trate, simplificando a l\u00f3gica geral do compilador nesta fase.</p>"},{"location":"entrega1/analisador-lexico/operadores-delimitadores-erros/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor 24/04/2025 1.0 Adiciona tabela de tokens Brunna Louise Mariana Let\u00edcia 24/04/2025 1.1 Decis\u00f5es, Desafios e Solu\u00e7\u00f5es Genilson Junior Mariana Let\u00edcia 27/06/2025 1.2 Atualiza\u00e7\u00e3o da documenta\u00e7\u00e3o para refletir o estado atual do c\u00f3digo do lexer Brunna Louise -"},{"location":"entrega2/analisador-sintatico/","title":"Analisador Sint\u00e1tico","text":""},{"location":"entrega2/analisador-sintatico/#visao-geral","title":"Vis\u00e3o Geral","text":"<p>O analisador sint\u00e1tico \u00e9 o componente central do compilador. Sua principal responsabilidade \u00e9 verificar se a sequ\u00eancia de tokens fornecida pelo analisador l\u00e9xico (<code>lexer.l</code>) obedece \u00e0 estrutura gramatical da linguagem.</p> <p>Al\u00e9m da valida\u00e7\u00e3o sint\u00e1tica, o parser desempenha duas outras fun\u00e7\u00f5es vitais:</p> <ol> <li>Constru\u00e7\u00e3o da \u00c1rvore Sint\u00e1tica Abstrata (AST): \u00c0 medida que as regras gramaticais s\u00e3o reconhecidas, o parser executa a\u00e7\u00f5es sem\u00e2nticas (c\u00f3digo em C) para construir uma representa\u00e7\u00e3o hier\u00e1rquica do c\u00f3digo-fonte, a AST.</li> <li>An\u00e1lise Sem\u00e2ntica Preliminar: O parser interage diretamente com a Tabela de S\u00edmbolos para gerenciar escopos, declarar vari\u00e1veis e fun\u00e7\u00f5es, e realizar a infer\u00eancia de tipos em tempo de an\u00e1lise.</li> </ol>"},{"location":"entrega2/analisador-sintatico/#configuracao-e-declaracoes-do-bison","title":"Configura\u00e7\u00e3o e Declara\u00e7\u00f5es do Bison","text":"<p>A primeira parte do arquivo define a interface entre o parser, o lexer e os m\u00f3dulos de dados (AST e Tabela de S\u00edmbolos).</p>"},{"location":"entrega2/analisador-sintatico/#union","title":"<code>%union</code>","text":"<p>A diretiva <code>%union</code> define um conjunto de tipos de dados que podem ser associados a tokens e regras gramaticais. Isso permite que o lexer passe valores ricos (como uma <code>struct Numero</code>) e que as regras do parser construam e passem ponteiros para n\u00f3s da AST (<code>NoAST*</code>).</p> <pre><code>%union {\n  char *str;\n  Numero numero;\n  int inteiro;\n  float real;\n  char* string;\n  NoAST* no;\n  NoAST* param_list;\n}\n</code></pre>"},{"location":"entrega2/analisador-sintatico/#declaracao-de-tokens-e-tipos-token-type","title":"Declara\u00e7\u00e3o de Tokens e Tipos (<code>%token</code>, <code>%type</code>)","text":"<p>Aqui s\u00e3o declarados os s\u00edmbolos terminais (tokens, vindos do lexer) e n\u00e3o-terminais (regras da gram\u00e1tica), associando-os aos tipos definidos na <code>%union</code>.</p> Declara\u00e7\u00e3o Exemplo Prop\u00f3sito <code>%token</code> <code>%token INDENT DEDENT PLUS</code> Define os tokens que n\u00e3o carregam valor. <code>%token &lt;tipo&gt;</code> <code>%token &lt;numero&gt; NUMBER</code> Define tokens que carregam um valor, especificando qual campo da <code>%union</code> usar. <code>%type &lt;tipo&gt;</code> <code>%type &lt;no&gt; program stmt</code> Define o tipo de valor que uma regra gramatical (n\u00e3o-terminal) ir\u00e1 retornar, geralmente um ponteiro para um n\u00f3 da AST."},{"location":"entrega2/analisador-sintatico/#precedencia-e-associatividade-de-operadores","title":"Preced\u00eancia e Associatividade de Operadores","text":"<p>Para resolver ambiguidades em express\u00f5es matem\u00e1ticas, s\u00e3o definidas a associatividade e a preced\u00eancia dos operadores. Operadores na mesma linha t\u00eam a mesma preced\u00eancia, e as linhas mais baixas t\u00eam maior preced\u00eancia.</p> <pre><code>%left PLUS MINUS   // Menor preced\u00eancia, associatividade \u00e0 esquerda\n%left TIMES DIVIDE // Maior preced\u00eancia, associatividade \u00e0 esquerda\n</code></pre>"},{"location":"entrega2/analisador-sintatico/#estrutura-da-gramatica","title":"Estrutura da Gram\u00e1tica","text":"<p>A gram\u00e1tica define a sintaxe v\u00e1lida da linguagem de forma hier\u00e1rquica.</p>"},{"location":"entrega2/analisador-sintatico/#regra-inicial-e-estrutura-do-programa","title":"Regra Inicial e Estrutura do Programa","text":"<p>A an\u00e1lise come\u00e7a pela regra <code>program</code>, que \u00e9 definida como uma lista de \"statements\" (<code>stmt_list</code>). A <code>stmt_list</code> \u00e9 uma sequ\u00eancia recursiva de <code>stmt</code>, que s\u00e3o as instru\u00e7\u00f5es individuais da linguagem. Ao final, o resultado \u00e9 atribu\u00eddo \u00e0 vari\u00e1vel global <code>raiz</code>, que se torna a raiz da AST completa.</p> <pre><code>program:\n    stmt_list  { raiz = $1; $$ = $1; }\n;\n\nstmt_list:\n    stmt\n  | stmt_list stmt\n;\n\nstmt:\n    def_stmt\n  | print_stmt\n  | while_statement\n  | if_stmt\n  | assignment_stmt\n  // ... e outras instru\u00e7\u00f5es\n;\n</code></pre>"},{"location":"entrega2/analisador-sintatico/#construcoes-de-controle-de-fluxo","title":"Constru\u00e7\u00f5es de Controle de Fluxo","text":"<p>A gram\u00e1tica define regras para estruturas como <code>if-elif-else</code> e <code>while</code>, construindo os n\u00f3s correspondentes na AST para representar a l\u00f3gica de controle.</p> <pre><code>if_stmt:\n    IF expr COLON block {\n        $$ = criarNoIf($2, $4);\n    }\n  | IF expr COLON block ELSE COLON block {\n        NoAST *if_node = criarNoIf($2, $4);\n        NoAST *else_node = criarNoElse($7);\n        $$ = criarNoSeq(if_node, else_node);\n    }\n;\n\nwhile_statement:\n    WHILE expr COLON block {\n        NoAST *no_while = criarNoPalavraChave(\"while\");\n        no_while-&gt;esquerda = $2; // Condi\u00e7\u00e3o\n        no_while-&gt;direita = $4;  // Corpo do la\u00e7o\n        $$ = no_while;\n    }\n;\n</code></pre>"},{"location":"entrega2/analisador-sintatico/#expressoes-e-operadores","title":"Express\u00f5es e Operadores","text":"<p>As regras <code>expr</code>, <code>term</code> e <code>factor</code> implementam a gram\u00e1tica de express\u00f5es, respeitando a preced\u00eancia definida anteriormente para construir a \u00e1rvore de opera\u00e7\u00f5es corretamente.</p> <pre><code>expr:\n    expr PLUS term  { $$ = criarNoOp('+', $1, $3); }\n  | term\n;\n\nterm:\n    term TIMES factor { $$ = criarNoOp('*', $1, $3); }\n  | factor\n;\n\nfactor:\n    LPAREN expr RPAREN { $$ = $2; }\n  | NUMBER { /* cria n\u00f3 num\u00e9rico */ }\n  | ID     { $$ = criarNoId($1); }\n;\n</code></pre>"},{"location":"entrega2/analisador-sintatico/#analise-semantica-e-integracao","title":"An\u00e1lise Sem\u00e2ntica e Integra\u00e7\u00e3o","text":"<p>O parser \u00e9 o ponto central de integra\u00e7\u00e3o dos diferentes m\u00f3dulos do compilador.</p>"},{"location":"entrega2/analisador-sintatico/#gerenciamento-de-escopo-com-indentdedent","title":"Gerenciamento de Escopo com INDENT/DEDENT","text":"<p>A estrutura de blocos da linguagem \u00e9 gerenciada pela regra <code>block</code>, que espera uma sequ\u00eancia de <code>INDENT</code>, uma lista de statements e um <code>DEDENT</code>. As a\u00e7\u00f5es de empilhar e desempilhar escopos na Tabela de S\u00edmbolos s\u00e3o coordenadas com o reconhecimento desses blocos, principalmente nas regras que os utilizam, como <code>def_stmt</code>.</p> <pre><code>// Um bloco \u00e9 definido pela indenta\u00e7\u00e3o\nblock:\n    INDENT stmt_list DEDENT { $$ = $2; }\n;\n\n// Exemplo: def_stmt usa 'block' para o corpo da fun\u00e7\u00e3o\ndef_stmt:\n    DEF ID LPAREN param_list RPAREN COLON block {\n        // ... (a\u00e7\u00e3o de empilhar escopo antes de processar 'block')\n        // ... (a\u00e7\u00e3o de desempilhar escopo ap\u00f3s processar 'block')\n    }\n;\n</code></pre>"},{"location":"entrega2/analisador-sintatico/#inferencia-de-tipo-em-atribuicoes","title":"Infer\u00eancia de Tipo em Atribui\u00e7\u00f5es","text":"<p>Uma das funcionalidades mais avan\u00e7adas do parser \u00e9 a infer\u00eancia de tipo. Quando uma nova vari\u00e1vel \u00e9 declarada atrav\u00e9s de uma atribui\u00e7\u00e3o, o parser analisa a express\u00e3o no lado direito para deduzir o tipo de dado da vari\u00e1vel e registr\u00e1-la corretamente na Tabela de S\u00edmbolos.</p> <pre><code>// parser.y - Regra de atribui\u00e7\u00e3o\nassignment_stmt:\n    ID ASSIGN expr {\n        $$ = criarNoOp('=', criarNoId($1), $3);\n\n        Simbolo* s = buscar_simbolo_escopo_atual(escopo_atual, $1);\n        if (!s) { // S\u00f3 executa se a vari\u00e1vel for nova neste escopo\n            int tipo_expr = deduzir_tipo_expr($3); // **INFER\u00caNCIA DE TIPO**\n            char* tipo_deduzido = \"int\"; // Padr\u00e3o\n\n            if (tipo_expr == TIPO_FLOAT) tipo_deduzido = \"float\";\n            else if (tipo_expr == TIPO_STRING) tipo_deduzido = \"char*\";\n            else if (tipo_expr == TIPO_BOOL) tipo_deduzido = \"bool\";\n\n            // Insere o s\u00edmbolo com o tipo de dado correto\n            inserir_simbolo(escopo_atual, $1, \"variavel\", tipo_deduzido);\n        }\n    }\n;\n</code></pre>"},{"location":"entrega2/analisador-sintatico/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor 27/06/2025 1.0 Cria\u00e7\u00e3o inicial da documenta\u00e7\u00e3o do analisador sint\u00e1tico (<code>parser.y</code>) Brunna Louise Genilson Silva"},{"location":"entrega2/arvore-sintatica/","title":"\u00c1rvore Sint\u00e1tica","text":""},{"location":"entrega2/arvore-sintatica/#arvore-de-derivacao-sintatica","title":"\u00c1rvore de Deriva\u00e7\u00e3o Sint\u00e1tica","text":"<p>Uma \u00e1rvore de deriva\u00e7\u00e3o sint\u00e1tica, tamb\u00e9m chamada de \u00e1rvore sint\u00e1tica ou parse tree, \u00e9 uma representa\u00e7\u00e3o hier\u00e1rquica que mostra como uma sequ\u00eancia de s\u00edmbolos de uma linguagem pode ser gerada a partir de sua gram\u00e1tica formal. Cada n\u00f3 da \u00e1rvore corresponde a um s\u00edmbolo da gram\u00e1tica: os n\u00f3s internos representam vari\u00e1veis ou n\u00e3o-terminais, enquanto as folhas representam os s\u00edmbolos terminais, que formam a entrada analisada. A constru\u00e7\u00e3o da \u00e1rvore segue as regras de produ\u00e7\u00e3o da gram\u00e1tica, partindo do s\u00edmbolo inicial at\u00e9 gerar a cadeia completa. </p> <p>Objetivos:</p> <ul> <li> <p>Clareza Sem\u00e2ntica: destaca opera\u00e7\u00f5es e estruturas l\u00f3gicas.</p> </li> <li> <p>Efici\u00eancia: reduz o tamanho da estrutura em mem\u00f3ria, facilitando percursos e transforma\u00e7\u00f5es.</p> </li> <li> <p>Base para Fases Posteriores: serve de suporte para an\u00e1lise de tipos, controle de escopo, otimiza\u00e7\u00f5es e gera\u00e7\u00e3o de c\u00f3digo.</p> </li> </ul> <p>A \u00e1rvore de deriva\u00e7\u00e3o sint\u00e1tica representa um c\u00f3digo intermedi\u00e1rio. Um c\u00f3digo intermedi\u00e1rio \u00e9 uma forma de representa\u00e7\u00e3o do programa que o compilador est\u00e1 analisando. Ele \u00e9 criado junto da an\u00e1lise l\u00e9xica e sint\u00e1tica antes de gerar o c\u00f3digo final de fato. A \u00e1rvore sint\u00e1tica \u00e9 constru\u00edda de forma a respeitar a estrutura hier\u00e1rquica e l\u00f3gica do c\u00f3digo. Por exemplo o c\u00f3digo:</p> <pre><code>x = 1 + 2/3;\n</code></pre> <p>Ao ser analisado pelo compilador, sua constru\u00e7\u00e3o na \u00e1rvore sint\u00e1tica seria a seguinte:</p> <pre><code>           (=)\n          /   \\\n        (id)   (expr)\n         |        |\n         x       (+)\n                /   \\\n             (num)   (/)\n               |    /   \\\n               1 (num) (num)\n                   |     |\n                   2     3\n</code></pre> <pre><code>Assign (=)\n\u251c\u2500\u2500 Identifier: x\n\u2514\u2500\u2500 Op(+)\n    \u251c\u2500\u2500 LiteralInt: 1\n    \u2514\u2500\u2500 Op(/)\n        \u251c\u2500\u2500 LiteralInt: 2\n        \u2514\u2500\u2500 LiteralInt: 3\n</code></pre> <p>Essa representa\u00e7\u00e3o deixa evidente n\u00e3o apenas a preced\u00eancia dos operadores com a divis\u00e3o sendo avaliada antes da soma, mas tamb\u00e9m como a AST reflete a estrutura l\u00f3gica do programa. Ao posicionar cada opera\u00e7\u00e3o em seu pr\u00f3prio n\u00edvel hier\u00e1rquico, fica claro:</p> <ul> <li> <p>Fluxo de avalia\u00e7\u00e3o: n\u00f3s mais profundos correspondem a opera\u00e7\u00f5es que devem ocorrer primeiro.</p> </li> <li> <p>Organiza\u00e7\u00e3o sem\u00e2ntica: dividindo express\u00f5es complexas em sub\u00e1rvores menores, facilita-se a an\u00e1lise e transforma\u00e7\u00f5es posteriores.</p> </li> <li> <p>Legibilidade para desenvolvedores: ao imprimir ou visualizar a AST, a \u00e1rvore hier\u00e1rquica serve como um diagrama compreens\u00edvel do comportamento do c\u00f3digo.</p> </li> </ul>"},{"location":"entrega2/arvore-sintatica/#criacao-da-arvore","title":"Cria\u00e7\u00e3o da \u00c1rvore","text":"<p>Nesse projeto, a cria\u00e7\u00e3o da \u00e1rvore sint\u00e1tica come\u00e7a com a defini\u00e7\u00e3o da estrutura que ser\u00e1 o n\u00f3 da \u00e1rvore. A estrutura abaixo foi utiliza, contendo todos os possiveis atributos necess\u00e1rios para alocar cada parte do c\u00f3digo analisado.</p> <pre><code>typedef struct noAST {\n    char operador;\n    int valor;\n    float valor_float;\n    char *valor_string;\n    char nome[32];\n    char delimitador;\n    char *palavra_chave;\n    Tipo tipo;\n    struct noAST *esquerda;\n    struct noAST *direita;\n    struct noAST *meio;\n} NoAST;\n</code></pre> <p>Veja mais aqui!</p> <p>Ap\u00f3s isso, foram definidas fun\u00e7\u00f5es de aloca\u00e7\u00e3o dessa estrutra na mem\u00f3ria conforme as regras de produ\u00e7\u00e3o definidas no parser sentissem necessidade, ao analisar determinada cadeia de tokens, criar e preencher os campos corretos da estrutura do n\u00f3, conforme prenchiam a estrutura da \u00e1rvore e faziam a an\u00e1lise sint\u00e1tica do c\u00f3digo. Como exempo, a fun\u00e7\u00e3o abaixo cria um n\u00f3 para um operador matem\u00e1tico com <code>=</code>, <code>+</code> ou <code>-</code>.</p> <pre><code>NoAST *criarNoOp(char op, NoAST *esq, NoAST *dir) {\n    NoAST *no = malloc(sizeof(NoAST));\n    no-&gt;operador = op;\n    no-&gt;esquerda = esq;\n    no-&gt;direita = dir;\n    no-&gt;meio = NULL;\n    no-&gt;tipo = TIPO_OP;\n    return no;\n}\n</code></pre> <p>Veja mais aqui!</p>"},{"location":"entrega2/arvore-sintatica/#analise-sintatica-e-montagem-da-ast","title":"An\u00e1lise Sint\u00e1tica e Montagem da AST","text":"<p>O  parser (analisador sint\u00e1tico), gerado pelo Bison a partir de <code>parser.y</code>, percorre a sequ\u00eancia de tokens emitida pelo lexer e, ao reconhecer cada regra da gram\u00e1tica, invoca a fun\u00e7\u00e3o de cria\u00e7\u00e3o de n\u00f3s correspondente para montar a AST. Esse processo \u00e9 naturalmente recursivo, pois regras compostas se aninham umas nas outras.</p> <ul> <li> <p>Reconhecimento de padr\u00f5es: sempre que um conjunto de tokens corresponde a uma produ\u00e7\u00e3o, o parser entra na a\u00e7\u00e3o associada.</p> </li> <li> <p>Cria\u00e7\u00e3o de n\u00f3s: dentro da a\u00e7\u00e3o, chama-se criarNoX(...) com os campos extra\u00eddos dos s\u00edmbolos da produ\u00e7\u00e3o.</p> </li> <li> <p>Conex\u00e3o de sub\u00e1rvores: os valores retornados por produ\u00e7\u00f5es menores s\u00e3o passados como par\u00e2metros para construir n\u00f3s de n\u00edvel mais alto.</p> </li> </ul> <p>Defini\u00e7\u00e3o de Fun\u00e7\u00e3o:</p> <pre><code>def_stmt:\n    DEF ID LPAREN RPAREN COLON block {\n        // fun\u00e7\u00e3o sem par\u00e2metros\n        $$ = criarNoFunDef($2, NULL, $6);\n    }\n  | DEF ID LPAREN param_list RPAREN COLON block {\n        // fun\u00e7\u00e3o com par\u00e2metros\n        $$ = criarNoFunDef($2, $4, $7);\n    }\n  ;\n</code></pre> <ul> <li> <p><code>$2</code> \u00e9 o nome da fun\u00e7\u00e3o (token ID).</p> </li> <li> <p><code>$4</code> corresponde \u00e0 lista de par\u00e2metros (se presente).</p> </li> <li> <p><code>$6</code> ou <code>$7</code> \u00e9 o n\u00f3 que representa o corpo (block).</p> </li> </ul> <p>Veja mais aqui!</p> <p>Fluxo:</p> <pre><code>def minhaFunc(a, b):\n    print(a + b)\n</code></pre> <ol> <li> <p>O lexer emite tokens: DEF, ID(minhaFunc), LPAREN, ID(a), COMMA, ID(b), RPAREN, COLON, ..., PRINT, LPAREN, ID(a), PLUS, ID(b), RPAREN.</p> </li> <li> <p>O parser casa DEF ID LPAREN param_list RPAREN COLON block e executa criarNoFunDef(\"minhaFunc\", param_list, blocoAST).</p> </li> <li> <p>Para param_list, cada par\u00e2metro gera um n\u00f3 criarNoParam(\"a\") e criarNoParam(\"b\"), conectados em sequ\u00eancia.</p> </li> <li> <p>A chamada print(a + b) gera um n\u00f3 criarNoChamada(\"print\", exprAST); onde exprAST \u00e9 constru\u00eddo via criarNoOp('+', criarNoId(\"a\"), criarNoId(\"b\")).</p> </li> <li> <p>O resultado final \u00e9 uma sub\u00e1rvore onde o n\u00f3 raiz \u00e9 NoAST de tipo TIPO_FUNDEF, com filhos apontando para par\u00e2metros e bloco.</p> </li> </ol> <p>Exibi\u00e7\u00e3o:</p> <pre><code>FunDef: minhaFunc\n\u251c\u2500\u2500 Params\n\u2502   \u251c\u2500\u2500 Param: a\n\u2502   \u2514\u2500\u2500 Param: b\n\u2514\u2500\u2500 Block\n    \u2514\u2500\u2500 FunCall: print\n        \u2514\u2500\u2500 Op(+)\n            \u251c\u2500\u2500 Identifier: a\n            \u2514\u2500\u2500 Identifier: b\n</code></pre>"},{"location":"entrega2/arvore-sintatica/#aplicacoes-e-praticas","title":"Aplica\u00e7\u00f5es e Pr\u00e1ticas","text":"<ul> <li> <p>An\u00e1lise Sem\u00e2ntica: ao construir cada n\u00f3 da AST, informa\u00e7\u00f5es sobre declara\u00e7\u00f5es e usos de identificadores s\u00e3o registradas na tabela de s\u00edmbolos (<code>tabela_simbolos.c</code>). Em seguida, percorre-se a \u00e1rvore para validar a exist\u00eancia de vari\u00e1veis e fun\u00e7\u00f5es antes da gera\u00e7\u00e3o de c\u00f3digo.</p> </li> <li> <p>Gera\u00e7\u00e3o de C\u00f3digo: o m\u00f3dulo de gera\u00e7\u00e3o (<code>gerarcodigo.c</code>) faz uma travessia da AST e emite trechos equivalentes em C. Cada tipo de n\u00f3 (atribui\u00e7\u00e3o, opera\u00e7\u00e3o, chamada de fun\u00e7\u00e3o) tem sua rotina, garantindo que o c\u00f3digo intermedi\u00e1rio reflita fielmente a estrutura da \u00e1rvore.</p> </li> </ul>"},{"location":"entrega2/arvore-sintatica/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor 31/05/2025 1.0 Cria\u00e7\u00e3o da p\u00e1gina e adi\u00e7\u00e3o de conte\u00fado Arthur Suares Mariana Let\u00edcia 27/06/2025 1.1 Altera\u00e7\u00f5es de conte\u00fado Genilson Silva"},{"location":"entrega2/tabela-simbolos/","title":"Tabela de S\u00edmbolos","text":"<p>A tabela de s\u00edmbolos \u00e9 uma estrutura de dados central do compilador, projetada para gerenciar informa\u00e7\u00f5es sobre todos os identificadores (vari\u00e1veis, fun\u00e7\u00f5es, par\u00e2metros) encontrados no c\u00f3digo-fonte. A sua principal fun\u00e7\u00e3o \u00e9 dar suporte \u00e0 an\u00e1lise sem\u00e2ntica, permitindo a verifica\u00e7\u00e3o de escopos, a detec\u00e7\u00e3o de redeclara\u00e7\u00f5es e a infer\u00eancia de tipos.</p> <p>Adicionalmente, ela \u00e9 uma pe\u00e7a fundamental para a etapa de gera\u00e7\u00e3o de c\u00f3digo, fornecendo os tipos de dados necess\u00e1rios para a tradu\u00e7\u00e3o do c\u00f3digo-fonte para a linguagem C. A implementa\u00e7\u00e3o utiliza uma hash table com tratamento de colis\u00f5es por encadeamento e uma estrutura de pilha para gerenciar escopos aninhados, refletindo a natureza de linguagens como Python.</p>"},{"location":"entrega2/tabela-simbolos/#estrutura-de-dados","title":"Estrutura de Dados","text":"<p>A implementa\u00e7\u00e3o \u00e9 baseada em duas <code>structs</code> principais: <code>Simbolo</code>, que armazena os dados de um identificador individual, e <code>TabelaSimbolos</code>, que representa um escopo contendo m\u00faltiplos s\u00edmbolos.</p>"},{"location":"entrega2/tabela-simbolos/#struct-simbolo","title":"<code>struct Simbolo</code>","text":"<p>Esta estrutura foi enriquecida para armazenar metadados detalhados sobre cada identificador, essenciais para as fases de an\u00e1lise e tradu\u00e7\u00e3o.</p> <pre><code>typedef struct Simbolo {\n    char* nome;                 // Nome do identificador (ex: \"minha_variavel\").\n    char* tipo;                 // Categoria do s\u00edmbolo (ex: \"variavel\", \"funcao\", \"param\").\n    char* tipo_simbolo;         // Tipo de dado do s\u00edmbolo (ex: \"int\", \"float\", \"char*\", \"bool\").\n    bool foi_traduzido;         // Flag para controlar a gera\u00e7\u00e3o de c\u00f3digo C.\n    char* tipo_retorno_funcao;  // Armazena o tipo de retorno, aplic\u00e1vel apenas a fun\u00e7\u00f5es.\n    struct Simbolo* proximo;    // Ponteiro para o pr\u00f3ximo s\u00edmbolo em caso de colis\u00e3o na hash.\n} Simbolo;\n</code></pre>"},{"location":"entrega2/tabela-simbolos/#struct-tabelasimbolos","title":"<code>struct TabelaSimbolos</code>","text":"<p>Representa um \u00fanico escopo. A liga\u00e7\u00e3o com escopos pais \u00e9 feita atrav\u00e9s do ponteiro <code>anterior</code>, formando uma pilha de escopos.</p> <pre><code>typedef struct TabelaSimbolos {\n    Simbolo* tabela[TAM_TABELA];      // A hash table (array de ponteiros para S\u00edmbolos).\n    struct TabelaSimbolos* anterior;  // Ponteiro para o escopo pai (superior).\n} TabelaSimbolos;\n</code></pre>"},{"location":"entrega2/tabela-simbolos/#funcionalidades","title":"Funcionalidades","text":"Fun\u00e7\u00e3o Descri\u00e7\u00e3o <code>criar_tabela()</code> Aloca e inicializa uma nova tabela de s\u00edmbolos (um novo escopo). <code>destruir_tabela(tabela)</code> Libera toda a mem\u00f3ria associada a uma tabela e seus s\u00edmbolos. <code>inserir_simbolo(tabela, nome, tipo, tipo_simbolo)</code> Adiciona um novo s\u00edmbolo ao escopo atual, incluindo sua categoria e tipo de dado. <code>buscar_simbolo(tabela, nome)</code> Busca um s\u00edmbolo no escopo atual e, se n\u00e3o encontrar, continua a busca recursivamente nos escopos pais at\u00e9 o escopo global. <code>buscar_simbolo_no_escopo_atual(tabela, nome)</code> Busca um s\u00edmbolo apenas no escopo fornecido, sem subir para os escopos pais. Essencial para detectar redeclara\u00e7\u00f5es. <code>empilhar_escopo(tabela_atual)</code> Cria um novo escopo (tabela) cujo escopo pai \u00e9 <code>tabela_atual</code>. <code>desempilhar_escopo(tabela_atual)</code> Descarta o escopo atual e retorna o ponteiro para o escopo pai. <code>imprimir_tabela(tabela)</code> Exibe o conte\u00fado de todos os escopos de forma aninhada para fins de depura\u00e7\u00e3o."},{"location":"entrega2/tabela-simbolos/#integracao-e-analise-semantica","title":"Integra\u00e7\u00e3o e An\u00e1lise Sem\u00e2ntica","text":"<p>A tabela de s\u00edmbolos \u00e9 gerenciada primariamente pelo analisador sint\u00e1tico (<code>parser.y</code>), que a utiliza para realizar a an\u00e1lise sem\u00e2ntica.</p>"},{"location":"entrega2/tabela-simbolos/#gerenciamento-de-escopo","title":"Gerenciamento de Escopo","text":"<p>O parser cria e destr\u00f3i escopos para refletir os blocos de c\u00f3digo da linguagem. Um novo escopo \u00e9 empilhado ao entrar em um bloco (<code>INDENT</code>) e desempilhado ao sair (<code>DEDENT</code>). A gram\u00e1tica que gerencia isso \u00e9 a regra <code>block</code>:</p> <pre><code>// parser.y\nblock:\n    INDENT stmt_list DEDENT {\n        $$ = $2;\n        escopo_atual = desempilhar_escopo(escopo_atual); // Desempilha ao final do bloco\n    }\n;\n\n// A regra de defini\u00e7\u00e3o de fun\u00e7\u00e3o, por exemplo, empilha o escopo antes de processar o bloco\ndef_stmt:\n    DEF ID LPAREN param_list RPAREN COLON {\n        escopo_atual = empilhar_escopo(escopo_atual); // Empilha para o corpo da fun\u00e7\u00e3o\n    } \n    block\n    ...\n;\n</code></pre>"},{"location":"entrega2/tabela-simbolos/#declaracao-de-variaveis-com-inferencia-de-tipo","title":"Declara\u00e7\u00e3o de Vari\u00e1veis com Infer\u00eancia de Tipo","text":"<p>Esta \u00e9 a funcionalidade sem\u00e2ntica mais importante. Quando uma atribui\u00e7\u00e3o (<code>=</code>) \u00e9 reconhecida, o parser realiza as seguintes a\u00e7\u00f5es:</p> <ol> <li>Verifica se a vari\u00e1vel j\u00e1 existe no escopo atual usando <code>buscar_simbolo_no_escopo_atual</code>.</li> <li>Se a vari\u00e1vel \u00e9 nova, o parser chama a fun\u00e7\u00e3o <code>deduzir_tipo_expr</code> para analisar a express\u00e3o \u00e0 direita do <code>=</code> e inferir seu tipo de dado (e.g., uma soma de inteiros resulta em <code>TIPO_INT</code>, uma divis\u00e3o resulta em <code>TIPO_FLOAT</code>).</li> <li>Finalmente, insere a nova vari\u00e1vel na tabela de s\u00edmbolos com o tipo de dado inferido.</li> </ol> <pre><code>// parser.y - Regra de atribui\u00e7\u00e3o\nassignment_stmt:\n    ID ASSIGN expr {\n        $$ = criarNoOp('=', criarNoId($1), $3);\n\n        Simbolo* s = buscar_simbolo_escopo_atual(escopo_atual, $1);\n        if (!s) { // S\u00f3 insere se for a primeira vez neste escopo\n            char* tipo_deduzido = \"int\"; // Padr\u00e3o\n            int tipo_expr = deduzir_tipo_expr($3);\n\n            if (tipo_expr == TIPO_FLOAT) {\n                tipo_deduzido = \"float\";\n            } else if (tipo_expr == TIPO_STRING) {\n                tipo_deduzido = \"char*\";\n            } else if (tipo_expr == TIPO_BOOL) {\n                tipo_deduzido = \"bool\";\n            }\n            // Insere com o tipo de dado correto!\n            inserir_simbolo(escopo_atual, $1, \"variavel\", tipo_deduzido);\n        }\n    }\n;\n</code></pre>"},{"location":"entrega2/tabela-simbolos/#uso-na-geracao-de-codigo","title":"Uso na Gera\u00e7\u00e3o de C\u00f3digo","text":"<p>A tabela de s\u00edmbolos \u00e9 passada para o m\u00f3dulo de gera\u00e7\u00e3o de c\u00f3digo (<code>gerar_codigo.c</code>), onde \u00e9 usada para traduzir o c\u00f3digo para C. O campo <code>foi_traduzido</code> \u00e9 fundamental aqui para lidar com a declara\u00e7\u00e3o de vari\u00e1veis em C.</p> <p>Em C, uma vari\u00e1vel deve ser declarada (<code>int x;</code>) antes de seu primeiro uso. Para simular isso, o gerador de c\u00f3digo, ao encontrar uma atribui\u00e7\u00e3o, consulta a tabela:</p> <ul> <li>Se <code>s-&gt;foi_traduzido</code> for <code>false</code>, significa que esta \u00e9 a primeira vez que a vari\u00e1vel aparece. O gerador ent\u00e3o imprime a declara\u00e7\u00e3o do tipo (ex: <code>int</code>) antes da atribui\u00e7\u00e3o e marca o flag como <code>true</code>.</li> <li>Nas pr\u00f3ximas vezes que a mesma vari\u00e1vel for usada, o flag estar\u00e1 <code>true</code>, e o gerador de c\u00f3digo n\u00e3o imprimir\u00e1 a declara\u00e7\u00e3o de tipo novamente.</li> </ul> <pre><code>// gerar_codigo.c - Trecho da gera\u00e7\u00e3o de atribui\u00e7\u00e3o\nif (node-&gt;operador == '=') {\n    if (node-&gt;esquerda &amp;&amp; node-&gt;esquerda-&gt;tipo == TIPO_ID) {\n        Simbolo* s = buscar_simbolo(tabela, node-&gt;esquerda-&gt;nome);\n        // Se o s\u00edmbolo existe e ainda n\u00e3o foi traduzido/declarado\n        if (s &amp;&amp; !s-&gt;foi_traduzido){\n            fprintf(out, \"%s \", s-&gt;tipo_simbolo); // Imprime \"int\", \"float\", etc.\n            s-&gt;foi_traduzido = true;              // Marca como traduzido\n        }\n    }\n    gerar_codigo_c(node-&gt;esquerda, out, tabela);\n    fprintf(out, \" = \");\n    gerar_codigo_c(node-&gt;direita, out, tabela);\n}\n</code></pre>"},{"location":"entrega2/tabela-simbolos/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Data Vers\u00e3o Descri\u00e7\u00e3o Autor Revisor 02/06/2025 1.0 Adiciona vers\u00e3o inicial do documento de tabela de s\u00edmbolos. Brunna Louise Mariana Let\u00edcia 27/06/2025 1.1 Atualiza documenta\u00e7\u00e3o para refletir estado atual do c\u00f3digo. Brunna Louise Genilson Silva"},{"location":"entrega3/c%C3%B3digo-final/","title":"Gera\u00e7\u00e3o de C\u00f3digo","text":""},{"location":"entrega3/c%C3%B3digo-final/#visao-geral-e-arquitetura","title":"Vis\u00e3o Geral e Arquitetura","text":"<p>O m\u00f3dulo gerarcodigo.c \u00e9 a fase final e uma das mais complexas do compilador. Sua fun\u00e7\u00e3o \u00e9 receber a \u00c1rvore Sint\u00e1tica Abstrata (AST) validada pelo parser e traduzi-la em um programa C completo, funcional e semanticamente equivalente, que \u00e9 ent\u00e3o salvo em output.c.</p> <p>A arquitetura de gera\u00e7\u00e3o de c\u00f3digo foi projetada para ser robusta e otimizada, seguindo um fluxo de m\u00faltiplos passos:</p>"},{"location":"entrega3/c%C3%B3digo-final/#analise-preliminar-de-necessidades-verificar_necessidade_concatenar","title":"An\u00e1lise Preliminar de Necessidades (verificar_necessidade_concatenar):","text":"<p>Antes de gerar qualquer c\u00f3digo, \u00e9 feita uma passagem r\u00e1pida pela AST para verificar se o c\u00f3digo fonte utiliza funcionalidades que exigem c\u00f3digo auxiliar em C (concatena\u00e7\u00e3o de strings). Ela ativa um flag global (precisa_concatenar_helper) se encontrar tal necessidade. Esta etapa \u00e9 uma otimiza\u00e7\u00e3o que garante que o c\u00f3digo final gerado seja limpo e n\u00e3o contenha fun\u00e7\u00f5es auxiliares desnecess\u00e1rias.</p>"},{"location":"entrega3/c%C3%B3digo-final/#organizacao-da-geracao-do-codigo-gerar_programa_c","title":"Organiza\u00e7\u00e3o da Gera\u00e7\u00e3o do C\u00f3digo (gerar_programa_c):","text":"<p>Esta fun\u00e7\u00e3o atua orquestrando a montagem do arquivo output.c em uma ordem l\u00f3gica e v\u00e1lida para o compilador C:</p>"},{"location":"entrega3/c%C3%B3digo-final/#inclusao-de-cabecalhos","title":"Inclus\u00e3o de Cabe\u00e7alhos:","text":"<p>Inclui bibliotecas padr\u00e3o como , ,  e, condicionalmente, ."},{"location":"entrega3/c%C3%B3digo-final/#injecao-de-codigo-auxiliar","title":"Inje\u00e7\u00e3o de C\u00f3digo Auxiliar:","text":"<p>Com base no flag ativado na an\u00e1lise, esta etapa injeta o c\u00f3digo C completo para fun\u00e7\u00f5es auxiliares, como por exemplo concatenar_strings, garantindo que elas estejam definidas antes de serem usadas.</p>"},{"location":"entrega3/c%C3%B3digo-final/#geracao-de-funcoes-definidas","title":"Gera\u00e7\u00e3o de Fun\u00e7\u00f5es Definidas:","text":"<p>A fun\u00e7\u00e3o gerar_funcoes \u00e9 chamada para traduzir todas as fun\u00e7\u00f5es definidas pelo usu\u00e1rio no c\u00f3digo de entrada.</p>"},{"location":"entrega3/c%C3%B3digo-final/#geracao-da-funcao-main","title":"Gera\u00e7\u00e3o da Fun\u00e7\u00e3o main:","text":"<p>O corpo do script principal \u00e9 traduzido para se tornar o corpo da fun\u00e7\u00e3o main em C.</p>"},{"location":"entrega3/c%C3%B3digo-final/#logica-de-geracao-e-mapeamento-da-ast","title":"L\u00f3gica de Gera\u00e7\u00e3o e Mapeamento da AST","text":"<p>A tradu\u00e7\u00e3o da AST \u00e9 realizada por um conjunto de fun\u00e7\u00f5es recursivas, principalmente gerar_codigo_c e gerar_codigo_funcao. Elas operam com base no tipo de cada n\u00f3 da \u00e1rvore.</p>"},{"location":"entrega3/c%C3%B3digo-final/#mapeamento-de-nos-simples","title":"Mapeamento de N\u00f3s Simples:","text":""},{"location":"entrega3/c%C3%B3digo-final/#tipo_id-tipo_int-tipo_float-tipo_string-tipo_bool","title":"TIPO_ID, TIPO_INT, TIPO_FLOAT, TIPO_STRING, TIPO_BOOL:","text":"<p>S\u00e3o mapeados diretamente para seus equivalentes em C.</p>"},{"location":"entrega3/c%C3%B3digo-final/#tipo_sequencia","title":"TIPO_SEQUENCIA:","text":"<p>Garante a ordem correta das instru\u00e7\u00f5es, gerando o c\u00f3digo para o filho da esquerda e depois para o da direita.</p>"},{"location":"entrega3/c%C3%B3digo-final/#mapeamento-de-nos-complexos","title":"Mapeamento de N\u00f3s Complexos:","text":""},{"location":"entrega3/c%C3%B3digo-final/#tipo_op-operacoes","title":"TIPO_OP (Opera\u00e7\u00f5es):","text":"<p>Este \u00e9 o n\u00f3 mais inteligente do gerador. A l\u00f3gica if/else if/else implementada permite um tratamento diferenciado e sens\u00edvel ao contexto para cada operador:</p> <ul> <li> <p><code>= (Atribui\u00e7\u00e3o):</code> Gera uma instru\u00e7\u00e3o de atribui\u00e7\u00e3o em C. Uma l\u00f3gica crucial aqui \u00e9 a consulta \u00e0 Tabela de S\u00edmbolos usando o flag foi_traduzido para implementar a estrat\u00e9gia declara\u00e7\u00e3o em primeiro uso. Isso garante que o tipo da vari\u00e1vel (int, float, etc.) seja impresso apenas na primeira vez que ela \u00e9 usada em um escopo, evitando erros de \"redeclara\u00e7\u00e3o\" em C.</p> </li> <li> <p><code>+ (Adi\u00e7\u00e3o/Concatena\u00e7\u00e3o):</code> Este operador demonstra a capacidade de sobrecarga do compilador. A fun\u00e7\u00e3o determinar_tipo_no \u00e9 chamada para verificar os tipos dos operandos. Se algum for TIPO_STRING, o gerador produz uma chamada para a fun\u00e7\u00e3o auxiliar concatenar_strings. Caso contr\u00e1rio, ele gera uma soma num\u00e9rica, inserindo casts (float) quando necess\u00e1rio para garantir a precis\u00e3o aritm\u00e9tica.</p> </li> <li> <p><code>-, *, / (Outros Operadores):</code> Para esses operadores, a l\u00f3gica gera a express\u00e3o aritm\u00e9tica correspondente, tamb\u00e9m utilizando determinar_tipo_no para inserir casts (float) e garantir que opera\u00e7\u00f5es como a divis\u00e3o de inteiros produzam um resultado de ponto flutuante, espelhando o comportamento do Python.</p> </li> <li> <p><code>TIPO_PRINT:</code> \u00c9 mapeado para uma chamada printf() em C. A fun\u00e7\u00e3o gerarPrint executa um processo de duas passadas: primeiro, constr\u00f3i a string de formato (%d, %f, %s, etc.) inspecionando o tipo de cada argumento; depois, gera a lista de argumentos em si.</p> </li> <li> <p><code>TIPO_FUNCAO:</code> A gera\u00e7\u00e3o de uma fun\u00e7\u00e3o definida pelo usu\u00e1rio come\u00e7a com a chamada a inferir_tipo_retorno, que analisa o corpo da fun\u00e7\u00e3o em busca de uma instru\u00e7\u00e3o return para determinar o tipo de retorno (void, int, float, char*, bool). Em seguida, gera a assinatura completa da fun\u00e7\u00e3o em C, incluindo os tipos dos par\u00e2metros, e chama recursivamente gerar_codigo_funcao para preencher seu corpo.</p> </li> </ul>"},{"location":"entrega3/c%C3%B3digo-final/#decisoes-de-projeto-notaveis","title":"Decis\u00f5es de Projeto Not\u00e1veis","text":""},{"location":"entrega3/c%C3%B3digo-final/#sistema-de-tipos-hibrido","title":"Sistema de Tipos H\u00edbrido:","text":""},{"location":"entrega3/c%C3%B3digo-final/#a-inferencia-de-tipos-ocorre-em-dois-momentos-cruciais","title":"A infer\u00eancia de tipos ocorre em dois momentos cruciais:","text":"<p>No Parser (para decidir o tipo de armazenamento de uma nova vari\u00e1vel na Tabela de S\u00edmbolos) e no Gerador de C\u00f3digo (para decidir como traduzir uma express\u00e3o em tempo de gera\u00e7\u00e3o). Essa abordagem h\u00edbrida garante flexibilidade e corre\u00e7\u00e3o.</p>"},{"location":"entrega3/c%C3%B3digo-final/#seguranca-na-concatenacao","title":"Seguran\u00e7a na Concatena\u00e7\u00e3o:","text":"<p>Em vez de gerar chamadas strcat diretas e inseguras, o compilador adota a estrat\u00e9gia de injetar uma fun\u00e7\u00e3o auxiliar (concatenar_strings) que gerencia corretamente a aloca\u00e7\u00e3o de mem\u00f3ria (malloc), evitando segmentation faults e vazamentos de mem\u00f3ria.</p>"},{"location":"entrega3/c%C3%B3digo-final/#otimizacao-de-codigo-gerado","title":"Otimiza\u00e7\u00e3o de C\u00f3digo Gerado:","text":"<p>A an\u00e1lise preliminar para a inje\u00e7\u00e3o condicional de c\u00f3digo auxiliar \u00e9 para melhorar a qualidade do c\u00f3digo de sa\u00edda, evitando incluir c\u00f3digo morto e mantendo o arquivo output.c o mais limpo poss\u00edvel.</p>"}]}